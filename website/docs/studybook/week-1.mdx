---
id : week-1
title : Week 1
---

import Intro from '@site/src/components/Intro';
import Card from '@site/src/components/Card';
import Orange from '@site/src/components/Orange';

<Intro title="학습 목표">

# 음성 데이터에 대한 이해

</Intro>

---
<Card title='배경 설명'>

우리가 듣는 소리는 공기의 진동으로 우리는 자연스럽게 인식하고 구분할 수 있다.
그렇다면 컴퓨터는 소리를 어떻게 받아들일까?

현실에서의 음향은 다양한 주파수가 모여 복합적인 형태로 나타난다.
언뜻 봐서는 이것이 어떤 주파수들의 모임인지 구분하기 어렵다.
그래서 이 음파를 분해하기 위해 사용할 것이 푸리에 변환이다.

설명에 앞서 내용 이해를 쉽게 하기 위해 이 [영상](https://www.youtube.com/watch?v=eKSmEPAEr2U)을 보는 것을 권한다.
</Card>
---
## 푸리에 변환

$$

F(&omega;) = 

$$

정체를 알 수 없는 음파가 하나 있다고 가정해보자. 이 음파는 순수한 사인파 혹은 코사인파들의 합으로 이루어져있다.  
여기서 주기가 1인 사인파를 곱한 뒤, 그려진 그래프의 넓이를 합하는 과정을 진행해보자.  
그렇다면 넓이는 0이 나올 것이다. 반복되는 주기가 다르기 때문이다.  
<Card title='예시'>
이해를 돕기위해 간단한 예를 들어보면 sin(x)와 sin(2x)의 곱을 떠올려보자.  
이 두 그래프는 주기가 다르기 때문에 어떤 시점에서는 둘 다 같은 부호, 어떤 시점에서는 다른 부호를 가진다.  
그렇다면 곱했을 때 그래프 전체의 넓이는 0이 된다.  
</Card>

이제 주기를 바꿔가며 이 연산을 계속 진행해보자.
그러다가 어느 순간에 미지의 음파에 들어있는 사인파와 같은 주파수의 사인파를 곱하게 되면,  
그래프는 전체적으로 부호가 같은 부분이 많아지며, 
곱한 그래프의 넓이의 합은 양수 값이 되는 순간이 있을 것이다.  

이것이 미지의 음파 안에 들어있는 일부 사인파의 주기가 되는 것이다. 이런 식으로 미지의 음파가 어떤 순수한 사인파, 혹은 코사인파로 이루어져 있는지 알 수 있다.  
물론 코사인파의 주기도 알아보려면 코사인파의 주기를 바꿔가며 곱해봐야 한다.  
다만, 계산을 두 번 하는 것은 번거롭기에 오일러공식을 사용하여 사인 코사인 계산을 한번에 수행 할 수 있다.  
$$

cos(2&pi;ft) + isin(2&pi;ft) = e^i2&pi;ft

$$  
이 식에서 실수부는 코사인파의 진폭이고, 허수부는 사인파의 진폭이 된다.

**핵심적인 내용은 같은 주파수를 가진 음파를 곱할때, 그래프 넓이의 합이 양수가 된다는 것이다.**

---

## 이산 푸리에 변환 (DFT)
푸리에 변환 식은 적분식으로 연속적인 값을 다룬다.  
하지만 현실에서는 특정 시간에 대한 데이터포인트밖에 구할 수 없다.  
따라서 이산적인 입력에 맞는 푸리에 변환 필요성이 대두된다.

$$



$$

원래 푸리에 변환에서 바뀐 점
- &int; -> &Sigma;
- f(t) -> x_n : 연속 함수 -> 데이터포인트
- &omega; -> 2&pi;k/N : N개 샘플당 원을 k번 도는 주파수로 변환
- t -> n : 시간 t를 데이터포인트 인덱스 n으로 바꿈

측정 방법 또한 달라졌다. 이전에는 그래프 전체에 곱한 뒤 넓이를 봤다면, 이제는 추출해낸 데이터포인터 샘플에 사인,코사인파를 곱해서 더한 후 값을 확인한다.  
이 때 샘플의 3가지 특징이 있다.
<Card title='샘플의 3가지 특징'>
1. 샘플 간의 간격이 넓을수록 고주파수를 감지하기 어려워진다.
2. 신호의 길이가 짧을수록 주파수 bin이 더 넓어지게된다.
:::info[주파수 bin이란?]

아날로그적인 특성을 가진 주파수를 이산적으로 딱딱 나눈 것이다.  
예를 들어 세상에 존재하는 소리의 높낮이는 연속적이지만,  
피아노 건반은 특정 음높이만을 가지게 되고, 이 범위가 주파수 빈인 것이다.  
주파수 빈이 많을수록 더 정밀한 분석을 할 수 있다.
:::

3. 측정할 수 있는 0이 아닌 가장 낮은 주파수는 신호의 전체 지속시간과 동일한 주기의 주파수가 된다.
:::info[이게 무슨 말일까?]
주파수는 주기의 역수이다. f = 1/T  
예를 들어 측정 기간이 2초라면 공식에 의해 인식할 수 있는 가장 낮은 주파수는 0.5Hz이다.  
더 낮은 주파수를 인식하기 위해서는 측정 기간을 늘려야 한다.  
더 높은 주파수 빈들은 가장 낮은 주파수 빈의 정수배가 된다.  
0배, 1배, 2배 이런 식으로 이렇게 모든 샘플 개수만큼 있을 것이다.  
주파수 빈의 총 개수는 신호의 샘플 수 와 같은 것이다.  
샘플이 8개 라면, 가장 낮은 주파수의 0부터 7배 까지 8개의 빈이 존재하는 것이다.

:::
</Card>
푸리에 변환 시간 복잡도를 알아보자.  
N개의 샘플이 있고, 그에 따른 N개의 주파수 빈이 있다.  
그렇다면 샘플 N개에 각각 N개의 서로 다른 주파수를 곱해야하고, 시간 복잡도는 O(n^2)이 된다.  
샘플 수가 많아질수록 계산량이 기하급수적으로 늘어나게 된다.

---

## 고속 푸리에 변환 (FFT)
이산 푸리에 변환은 획기적인 방법이지만 연산 시간이 너무 오래걸린다는 단점이 있었다.  
그래서 더 적은 비용으로 연산할 수 있는 방법을 찾아내기 시작했다.  
그렇게 탄생한 것이 고속 푸리에 변환이다.  

이산 푸리에 변환 과정에서 정수배의 주파수 빈을 곱하는 연산을 한다.  
이 때 샘플을 짝수 번째와 홀수 번째로 나눈다.  
짝수 번째 샘플에 앞쪽 주파수 빈을 곱한 결과와 뒷 쪽 주파수 빈을 곱한 결과를 비교해보자.  
아까 예시로 보면 0\~3배, 4\~7배를 각각 곱한 결과를 비교하는 것이다.  

그랫더니 짝수 번째 샘플에서 앞쪽과 뒷쪽을 곱한 값이 같다는 것을 확인할 수 있었다!  
홀수 번째 샘플도 같은 과정을 거쳐보면 앞쪽과 뒷쪽을 곱한 값이 정확히 반대 부호를 가진다는 것을 확인할 수 있다!  
이를 통해 연산량을 절반으로 줄일 수 있었다. 이 과정을 재귀적으로 반복하다 보면 익숙한 식이 나올 것이다.  
$$

T(n) = 2T(n/2) + O(n)

$$  
이 식을 풀어보면 시간복잡도가 O(nlogn)인 것을 알 수 있다.
기존의 O(n^2)에서 아주 획기적으로 시간을 줄인 것을 볼 수 있다.  

---

## 단시간 푸리에 변환 (STFT)
이전 방법들은 신호에 어떤 주파수가 들어 있는지 알 수 있었지만, 발생 순서를 알아낼 수 없었다.  
단시간 푸리에 변환은 분리한 신호들이 어떤 순서로 발생했는지 알아내는 방법이다.  

짧은 시간 길이 단위인 윈도우로 쪼개서 푸리에 변환을 적용한다.  
이렇게 해서 나온 결과물은 시간, 주파수, 진폭이며 이 결과를 한번에 보여주는 것이 스펙트로그램이다.  

[스펙트로그램 예시 그림]("spectrogram_plot.png")

---

## 스펙트로그램
스펙트로그램은 x축은 시간, y축은 주파수, 밝기는 진폭 또는 진폭을 나타낸다.  
하지만 사람은 저주파수 대역의 차이(ex : 500 - 1000)는 쉽게 인지하는 반면,  
고주파수 대역의 차이(ex : 10000 - 10500)는 잘 인지하지 못하는 경향이 있다. 

그래서 인식성 개선을 위해 멜 스케일을 적용한 스펙트로그램을 사용한다.  
기존의 y축인 주파수 축이 선형적인 증가였다면,  
$$

m = 2595 * log_10(1 + f/700)

$$  
을 사용한 식으로 로그 스케일로 변형해서 y축을 구성한다.

[멜 스펙트로그램 예시 그림]("mel-spectrogram.png")

## 코드로 스펙트로그램 구현하기
---
<Card title='라이브러리 다운받기'>
```python
import librosa

array, sampling_rate = librosa.load(librosa.ex("trumpet"))
```
</Card>

> - **librosa** : 파이썬에서 오디오 및 음악 신호를 분석하기 위한 대표적인 라이브러리
> - `librosa.ex()` : 라이브러리 속 예제 파일의 trumpet 오디오 파일의 경로를 반환  
> - `librosa.load()` : 파일을 열고 오디오의  
>> 파형 데이터를 `array`에 저장,  
>> 1초당 몇 개의 샘플로 이루어져 있는지를 나타내는 정수를 `sampling_rate`에 저장   
---

<Card title='시간-진폭 그래프 그리기'>
```python
import matplotlib.pyplot as plt
import librosa.display

plt.figure().set_figwidth(12)
librosa.display.waveshow(array, sr=sampling_rate)
```
</Card>
> - x축은 시간, y축은 진폭인 그래프가 그려진다.  

---
<Card title='주파수-진폭 그래프 그리기'>
```python 
import numpy as np

dft_input = array[:4096]

window = np.hanning(len(dft_input))
windowed_input = dft_input * window
dft = np.fft.rfft(windowed_input)

amplitude = np.abs(dft)
amplitude_db = librosa.amplitude_to_db(amplitude, ref=np.max)

frequency = librosa.fft_frequencies(sr=sampling_rate, n_fft=len(dft_input))

plt.figure().set_figwidth(12)
plt.plot(frequency, amplitude_db)
plt.xlabel("Frequency (Hz)")
plt.ylabel("Amplitude (dB)")
plt.xscale("log")
```
</Card>
> - `dft_input` : 일부만 값을 가져옴    
>> 분할 정복에서 2로 나누는 연산의 효율성을 위해 2의 거듭제곱으로 설정
> - `window` : 양 끝이 0에 가까운 값, 가운데 부분은 1에 가까운 값을 가지는 함수
>> :::info[window의 필요성]
>> FFT는 신호의 끝과 시작이 부드럽게 연결된다고 가정하는데, `dft_input`으로 신호가 단절되어 시작과 끝이 달라짐.  
>> 그것으로 인한 노이즈가 생기는 것을 방지하기 위해 window를 생성함 
>> :::
> - `dft` : 각 주파수 빈에 해당하는 복소수들이 배열 형태로 저장
> - `np.abs(dft)` : `dft`에서 위상 정보는 제외하고 진폭 정보만 추출
> - `librosa.amplitude_to_db()` : 진폭을 dB스케일로 변환  
> - `ref=np.max` : 가장 큰 진폭 값을 0dB로 설정하고 나머지를 상대적인 크기로 표현

---

<Card title='스펙트로그램 시각화하기'>
```python
import numpy as np

D = librosa.stft(array)
S_db = librosa.amplitude_to_db(np.abs(D), ref=np.max)

plt.figure().set_figwidth(12)
librosa.display.specshow(S_db, x_axis="time", y_axis="hz")
plt.colorbar()
```
</Card>
> - `librosa.stft()` : 오디오 array 전체에 STFT 수행  
>> 내부적으로 신호를 짧은 구간으로 계속 잘라내고(윈도우),  
>> 각 구간마다 FFT 적용하는 과정을 자동으로 처리
> - `D` : 2차원 행렬  
>> 가로축(열)은 시간  
>> 세로축(행)은 주파수 빈  
>> 배열의 값은 각 시간-주파수 지점에서의 세기와 위상을 담은 복소수 값
> - `y_axis="hz"` : y축을 Hz 단위로 자동 변환  
>> 주파수를 로그 스케일로 보고싶다면 `y_axis="log"` 
> - `plt.colorbar()` : 그래프 옆에 색상 막대 추가  
>> 밝은 색(노란색)일수록 소리가 강하고, 어두운 색(파란색)일수록 소리가 약함

---
<Card title='멜 스펙트로그램 시각화하기'>
```python
S = librosa.feature.melspectrogram(y=array, sr=sampling_rate, n_mels=128, fmax=8000)

S_dB = librosa.power_to_db(S, ref=np.max)
plt.figure().set_figwidth(12)
librosa.display.specshow(S_dB, x_axis="time", y_axis="mel", sr=sampling_rate, fmax=8000)
plt.colorbar()
```
</Card>
> - `librosa.feature.melspectrogram()` : 내부적으로 STFT를 수행한 후,  
>> 그 결과에 멜 필터뱅크를 적용하여 멜 스펙토그램을 계산
>> - **멜 필터뱅크** : 저주파 대역은 넓게, 고주파 대역은 좁게 압축하여 사람이 인식하기 쉽게 함.
> - `n_mels` : 멜 필터의 개수를 128개로 지정  
>> 멜 스펙트로그램의 y축 해상도가 128이 됨을 의미 (해상도가 높을수록 세밀하게 표현 가능)
> - `fmax` : 분석할 주파수의 상한선을 8000Hz로 제한  
>> 이보다 높은 주파수는 계산에서 제외됨
> - `S` : 시간-멜 주파수에 대한 진폭의 제곱(에너지) 값을 담고 있는 2차원 배열
> - `librosa.power_to_db()` : 에너지를 로그 스케일에 맞추어 dB로 전환
> - `librosa.display.specshow()` : `S_dB`를 시각화하는 함수

---

[실행 코드](https://colab.research.google.com/drive/18AgFkh-d9zeifE84Q6dvrPZI-lqxWEPe#scrollTo=YhHHQwxTIIaB)